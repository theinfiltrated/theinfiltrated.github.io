<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Francesco Provino</title>
<generator uri="https://github.com/jekyll/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="/feed.xml" />
<link rel="alternate" type="text/html" href="" />
<updated>2015-06-06T14:18:23+02:00</updated>
<id>/</id>
<author>
  <name>Francesco Provino</name>
  <uri>/</uri>
  
</author>


  

<entry>
  <title type="html"><![CDATA[The birth and death of RAID]]></title>
  <link rel="alternate" type="text/html" href="/The_birth_and_death_of_RAID/" />
  <id>/The_birth_and_death_of_RAID</id>
  <published>2015-06-06T00:00:00+02:00</published>
  <updated>2015-06-06T00:00:00+02:00</updated>
  <author>
    <name>Francesco Provino</name>
    <uri></uri>
    
  </author>
  <content type="html">
    &lt;p&gt;Le prime notizie relative al RAID risalgono alla fine degli anni ‘70, quando le macchine UNIX midrange iniziarono a dotarsi di quello che oggi chiameremmo “RAID Software”; prima c’erano solo sistemi per la correzione di errori in memoria, ma di tipo offline.&lt;/p&gt;

&lt;h2 id=&quot;pubblicit-progresso&quot;&gt;Pubblicità progresso&lt;/h2&gt;
&lt;p&gt;Fa sempre bene ricordare come il RAID non sia una soluzione che riguarda la &lt;strong&gt;sicurezza&lt;/strong&gt; dei dati: il RAID è una soluzione che riguarda la &lt;em&gt;continuità del servizio&lt;/em&gt;. Ovvero, un array RAID permette di &lt;em&gt;continuare a lavorare&lt;/em&gt; durante un guasto, ma è implicito che ci si debba immediatamente prodigare per sostituire il componente guasto e non si possa fare a meno di un sistema di backup.&lt;/p&gt;

&lt;p&gt;Il RAID non sostituisce il backup, &lt;strong&gt;mai&lt;/strong&gt;: sono due sistemi concettualmente ed operativamente diversi; se il RAID è online (cioè utilizzato per l’accesso ai dati di lavoro), e garantisce la continuità del servizio, il backup è invece offline, off-site e fornisce archiviazione, conservazione e sicurezza dei dati.
Il backup in genere è una soluzione di &lt;em&gt;disaster recovery&lt;/em&gt;, il RAID è &lt;em&gt;risk mitigation&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;scsi-golden-age&quot;&gt;SCSI Golden Age&lt;/h2&gt;
&lt;p&gt;L’utente medio ricorderà probabilmente i controller entry level Adaptec o LSI dei primi anni ‘90, nati principalmente per supplire allo scadente RAID software integrato in Windows… ancora oggi parecchio deficitario rispetto all’esemplare implementazione di &lt;strong&gt;md&lt;/strong&gt; su Linux.
Le tipiche configurazioni prevedevano RAID 5, tre-cinque dischi (rigorosamente &lt;em&gt;dispari&lt;/em&gt;, per agevolare il calcolo della parità)… fino all’inizio degli anni 2000, i dischi costavano parecchio e non c’erano alternative in quella fascia di prezzo.&lt;/p&gt;

&lt;p&gt;Inoltre, le CPU x86 erano ancora pressapoco dei giocattoli, che mal sopportavano l’overhead dei livelli RAID con parità. I SO avevano ancora una gestione delle code di I/O abbastanza primitiva; l’offloading del calcolo all’ASIC del controller era una manna dal cielo. Da metà degli anni ‘90 il RAID hardware in qualsiasi macchina server viene considerato praticamente obbligatorio, e in una decade diventa &lt;em&gt;commodity&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ogni array che si rispetti ha i suoi dischi SCSI da 73Gb a 10kRPM, il RAID 5 &lt;em&gt;regge&lt;/em&gt; perché il fallimento dovuto ad &lt;a href=&quot;http://en.wikipedia.org/wiki/RAID#URE&quot;&gt;URE&lt;/a&gt; è abbastanza improbabile date le dimensioni degli HDD.
Da segnalare anche la diffusione nelle motherboard consumer dei cosidetti “&lt;em&gt;FakeRAID&lt;/em&gt;”, implementazioni puramente software e supportate quasi unicamente da Windows. Sono generalmente non troppo prestazionali o affidabili, e poco impiegate in ambito enterprise.&lt;/p&gt;

&lt;h2 id=&quot;per-dipingere-una-parete-grande-ci-vuole-un-pennello-grande&quot;&gt;Per dipingere una parete grande, ci vuole un pennello grande&lt;/h2&gt;
&lt;p&gt;Saltiamo avanti di due decenni, siamo negli anni 2010 (chissà che convenzione tireranno fuori riguardo queste decadi, al momento lo scrivo per esteso): i dischi raggiungono capacità di svariati Tb, il costo dello storage è in caduta libera, il fallimento per URE mette fuori dai giochi i livelli RAID con singola parità.&lt;/p&gt;

&lt;p&gt;Il RAID 10 viene universalmente adottato in ambito enterprise, affiancato dal RAID 6 o livelli proprietari (aventi comunque almeno doppia parità) per l’archiviazione massiva.
Assistiamo inoltre ad una ulteriore evoluzione del RAID software: le prestazioni delle CPU rendono &lt;strong&gt;md&lt;/strong&gt; più che adeguato per la maggior parte degli array-use_case; inoltre, con la comparsa di &lt;em&gt;ZFS&lt;/em&gt; l’utente può usufruire di un filesystem che fa anche RAID (con tripla parità!) e &lt;em&gt;volume management&lt;/em&gt; avanzato… permette anche di impostare dispositivi per il caching!
Ciononostante, il RAID hardware viene ancora preferito in sistemi di produzione per alcune caratteristiche avanzate:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;possibilità di fare caching con analisi &lt;em&gt;euristica&lt;/em&gt; dei blocchi più utilizzati su cache molto grandi (anche decine di Gb);&lt;/li&gt;
  &lt;li&gt;blind swap, ovvero sostituzione dei dischi a caldo e ricostruzione dell’array senza nessun altro intervento da parte dell’operatore (spostando la gestione dell’array dal system admin all’operatore hardware);&lt;/li&gt;
  &lt;li&gt;batterie interne, che anche in caso di totale failure dell’alimentazione permettono al controller di terminare le scritture o almeno memorizzarle su dispositivi a stato solido fino al successivo recovery;&lt;/li&gt;
  &lt;li&gt;replica remota su altri controller con latenze molto basse;&lt;/li&gt;
  &lt;li&gt;OS-agnosticità, tanto da poter essere montati su dispositivi come SAN, NAS, DAS ecc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il RAID è una pratica ormai assolutamente standardizzata e &lt;strong&gt;implicita&lt;/strong&gt; in ogni installazione di un certo livello.&lt;/p&gt;

&lt;h2 id=&quot;and-thanks-for-all-the-bits&quot;&gt;…and thanks for all the bits&lt;/h2&gt;

&lt;p&gt;E allora, perché nel titolo parlo di &lt;em&gt;morte&lt;/em&gt; del RAID? 
La domanda da porsi è se il concetto di unità di storage in RAID (per come lo intendiamo oggi, assistito da un controller hardware in particolare) abbia ancora senso con l’avvento degli SSD di nuova generazione, per i seguenti motivi:&lt;/p&gt;

&lt;h4 id=&quot;prestazioni-del-bus&quot;&gt;Prestazioni del bus&lt;/h4&gt;
&lt;p&gt;Sfruttando le connessioni PCI-E (o, ultimamente, gli slot della &lt;a href=&quot;http://www-03.ibm.com/systems/x/options/storage/solidstate/exflashdimm/index.html&quot;&gt;RAM&lt;/a&gt;), gli SSD permettono prestazioni teoricamente equivalenti alle massime ottenibili da un controller RAID, poiché sfruttano lo stesso bus di sistema per comunicare con la cpu.&lt;/p&gt;

&lt;h4 id=&quot;parallelismoprestazioni&quot;&gt;Parallelismo/Prestazioni&lt;/h4&gt;
&lt;p&gt;Le maggiori prestazioni ottenuti dai controllers compiendo I/O in parallelo su dischi rotazionali, oggi sono replicabili leggendo o scrivendo in contemporanea (striping) da un numero &lt;em&gt;praticamente arbitrario&lt;/em&gt; di NAND, solamente “limitato dal controller”; questa volta, quello dell’SSD. &lt;/p&gt;

&lt;p&gt;Da qui la crescita esplosiva nelle prestazioni degli ultimi SSD messi in commercio, che arrivano a picchi di quasi 4Gb/s (GigaBYTE, non Bit) R/W, con latenze bassissime.
E se ci sono ancora obiezioni sulla capacità, basta guardare agli &lt;a href=&quot;http://www.fusionio.com/data-sheets/iomemory-sx300-atomic-series/&quot;&gt;ultimi ritrovati&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;parallelismoaffidabilit&quot;&gt;Parallelismo/Affidabilità&lt;/h4&gt;
&lt;p&gt;La maggior affidabilità del RAID di dischi rotazionali (RAID 10, ovviamente) è data dal poter eseguire letture e scritture in parallelo (stavolta, cloning) su “pezzi di hardware” distinti, e grazie ad uno strato software di recuperare eventuali fallimenti… esattamente ciò che viene fatto &lt;em&gt;NAND per NAND&lt;/em&gt; dagli attuali SSD enterprise, che spesso espongono una capacità effettiva minore (anche del 30%) per potere, grazie alla logica del controller, tenere alcuni settori &lt;em&gt;spare&lt;/em&gt; che generalmente vengono utilizzati come &lt;strong&gt;settori di parità&lt;/strong&gt; a la RAID con parità (multipla!).&lt;/p&gt;

&lt;p&gt;Questa architettura sembra funzionare molto bene per via dell’enorme numero di &lt;em&gt;nodi&lt;/em&gt; per stripes e il grande “dominio di parità”; il controller riesce a tenere conto con discreta precisione dello stato di salute delle singole componenti, e generalmente rimpiazza le NAND che si avvicinano a fine vita con quelle precedentemente tenute &lt;em&gt;a riposo&lt;/em&gt; prima che ci possa essere un sostanziale degradamento di prestazioni o affidabilità.
Un esempio di queste funzionalità viene molto chiaramente descritto &lt;a href=&quot;http://www.fusionio.com/blog/adaptive-flashback&quot;&gt;qui&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;so-what&quot;&gt;So what?&lt;/h1&gt;
&lt;p&gt;A mio parere, ci avviciniamo ad un cambio di paradigma nel quale il supporto di memorizzazione a stato solido sarà affidabile e prestazionale quanto un controller RAID, rendendone di fatto superfluo l’utilizzo, limitatamente almeno allo storage locale.
La battaglia si sta già svolgendo, specialmente fra gli algoritmi per il wear-leveling e livelli di RAID-ridondanza “interni”; ne parlano molto gli ultimi papers di IBM sui loro nuovi storage all-flash e altri di Intel e FusionIO.&lt;/p&gt;

&lt;p&gt;Costano troppo? Space-wise, ancora per qualche anno. IOPS-wise, c’è già stato il sorpasso. Per fare gli IOPS di un SSD enterprise ci vogliono una batteria di dischi SAS più un controller RAID con una cache mica da ridere… e se non li puoi hostare dentro la macchina singola, ti serve anche una SAN, che presa da sola peggiora l’affidabilità del sistema. Altrimenti ne servono due, con due switches FC, HBA ridondanti, ecc; ed ecco che la soluzione con storage locale torna ad essere concorrenziale sia sul prezzo che nella semplicità di gestione, magari assistita da una replica block-level.&lt;/p&gt;

&lt;p&gt;Naturalmente, lo use-case che immagino è quello di workload mission-critical; non certo di quello di consolidamento dello storage nel quale latenza, prestazioni pure e semplicità dell’infrastruttura passano in secondo piano.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/The_birth_and_death_of_RAID/&quot;&gt;The birth and death of RAID&lt;/a&gt; è stato originariamente pubblicato da Francesco Provino il &lt;a href=&quot;&quot;&gt;Francesco Provino&lt;/a&gt; su June 06, 2015.&lt;/p&gt;

  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[L'insostenibile leggerezza dello specchio]]></title>
  <link rel="alternate" type="text/html" href="/why_dslr_arent_going_anywhere/" />
  <id>/why_dslr_arent_going_anywhere</id>
  <published>2015-05-23T00:00:00+02:00</published>
  <updated>2015-05-23T00:00:00+02:00</updated>
  <author>
    <name>Francesco Provino</name>
    <uri></uri>
    
  </author>
  <content type="html">
    &lt;p&gt;Si parlava ovunque della imminente scomparsa delle DSLR a favore delle mirrorless; passato l’hype (che aveva preso un po’ anche me, non lo nego) del mercato e dell’opinionista fotografico medio, possiamo inquadrare meglio il topic dal punto di vista dell’utilizzatore prosumer/professionale.
A mio parere, le DSLR sono qui per restare. Ancora per molto, molto tempo.
Ne sono così convinto, che una delle mie ultime acquisizioni è stata proprio un’ottica manual focus per DSLR.
Proviamo a capire perché.&lt;/p&gt;

&lt;h2 id=&quot;autonomia&quot;&gt;Autonomia&lt;/h2&gt;
&lt;p&gt;Una DSLR avrà sempre un’autonomia superiore a parità di sensore rispetto ad una mirrorless, perché può tenere attivo il sensore soltanto poche frazioni di secondo versus tutto il tempo che serve per comporre l’inquadratura e mettere a fuoco. Ovvero, resta con una buona fetta dell’elettronica “spenta” durante buona parte dell’utilizzo; al contrario, in una mirrorless il sensore deve essere sempre acceso per focheggiare, misurare la
luce ecc.
Questo inoltre riscalda il sensore, lo rovina prima, crea rumore termico, richiede batterie più grandi.&lt;/p&gt;

&lt;h2 id=&quot;dimensioni&quot;&gt;Dimensioni&lt;/h2&gt;
&lt;p&gt;Batterie più grandi vogliono dire dimensioni più grandi e potrebbe anche succedere che una DSLR, a parità di autonomia, abbia dimensioni complessive più piccole di una mirrorless (si recupera lo spazio mirabox con il supplemento di batteria). La cosa potrebbe andare bene per macchine poco professionali da 300 scatti a carica, ma per qualsiasi impiego di reportage, il gioco si fa duro…&lt;/p&gt;

&lt;p&gt;Non dimentichiamo inoltre che le dimensioni complessive sono influenzate anche dai comandi: a parità di
numero di ghiere e pulsanti, la cui numerosità e dimensionamento è dettata da esigenze operative e fisiologiche precise, non vedo particolari vantaggi dimensionali delle mirrorless su un corpo macchina professionale.
Inutile girarci attorno, ma un corpo PRO &lt;strong&gt;deve&lt;/strong&gt; avere delle dimensioni simili alle attuali ammiraglie Nikon e Canon (D4s e 1Dx) per consentire una impugnatura salda e comoda anche in posizione verticale e con ottiche voluminose e pesanti.&lt;/p&gt;

&lt;h2 id=&quot;corredo&quot;&gt;Corredo&lt;/h2&gt;
&lt;p&gt;Bisogna considerare che il corpo macchina è spesso una componente dimensionalmente minoritaria rispetto a tutto il resto dell’attrezzatura professionale, pensiamo a luci ed ottiche… spesso questo “&lt;em&gt;schiacciante&lt;/em&gt;” vantaggio a favore delle mirrorless è stato eccessivamente enfatizzato dal marketing, ma non dimentichiamo che esistono delle precise motivazioni ottiche per le quali un 300 f2.8 non può essere parecchio più piccolo degli attuali.&lt;/p&gt;

&lt;h2 id=&quot;qualit-delle-ottiche&quot;&gt;Qualità delle ottiche&lt;/h2&gt;
&lt;p&gt;Esistono vantaggi reali nell’eliminare il box specchio dal punto di vista del design ottico, sopratutto nel design di ottiche grandangolari. La loro focale infatti spesso è minore delle dimensioni fisiche occupate dallo specchio; ovvero, dovremmo ritrovarci con il nocciolo ottico &lt;strong&gt;dentro&lt;/strong&gt; lo specchio… la cosa viene risolta (vado molto a spanne) disegnando un grandongolare standard e aggiungendo un “telescopio” che permette la corretta formazione dell’immagine sul sensore anche se &lt;strong&gt;tutta&lt;/strong&gt; l’ottica dista dal sensore parecchio più della distanza focale. Questo vantaggio esiste solamente per focali dai 50mm in giù; già sopra i 35mm all’incirca, (lo spazio retrofocale occupato dallo specchio) gli schemi ottici sono abbastanza equivalenti.&lt;/p&gt;

&lt;p&gt;Inoltre, i sensori digitali hanno messo in luce un limite dei grandangolari simmetrici: per ovvie motivazioni ottiche, i raggi ai bordi del circolo di copertura arrivano &lt;em&gt;parecchio&lt;/em&gt; inclinati sul sensore. Sembrano esserci problemi con CCD e CMOS rispetto alla pellicola: se quest’ultima offriva una superficie sensibile praticamente piatta (anche se sul colore avremmo potuto vedere qualche shift dato dalla profondità dei layers), i sensori digitali possiamo immaginarli con pixel formati da scatole quadrate senza una faccia (dalla quale entra la luce) e la superficie sensibile sulla faccia opposta.&lt;/p&gt;

&lt;p&gt;Va da sè che parte dell’informazione luminosa si perda sulle facce &lt;em&gt;non sensibili&lt;/em&gt; al crescere dell’angolo con il quale incide la radiazione. A riguardo, Leica/Dalsa sembrano avere risolto la problematica aggiungendo delle microlenti (stile Fresnel) sulla superficie del sensore, che unite ad un profiling software di ogni lente fanno un ottimo lavoro. Comunque, fino a 20mm gli schemi retrofocus del mondo reflex non si difendono malaccio, basti pensare a quelle meraviglie degli Zeiss ZF.&lt;/p&gt;

&lt;h2 id=&quot;messa-a-fuoco&quot;&gt;Messa a fuoco&lt;/h2&gt;
&lt;p&gt;La precisione del live view confrontato con il mirino ottico senza magnificazioni (0.8x rispetto all’ottica 50mm) è leggermente a favore del mirino digitale, che offre il lusso del di poter cambiare l’ingrandimento alla bisogna; mi chiedo però se sia realmente possibile focheggiare un 135mm a mano libera guardando i pixel 4:1… Un buon mirino ottico con la giusta magnificazione (io uso il DG-2 su Nikon, prima avevo un KatzEye sulla digitale), può ancora vincere in un contesto di reportage d’azione.&lt;/p&gt;

&lt;p&gt;Ovviamente, per qualsiasi impiego dove la precisione pixel-level è un requisito, il live view è comunque necessario.
Tutti i corpi reflex attuali offrono il live view a richiesta, ne segue che per impieghi di tipo &lt;strong&gt;studio&lt;/strong&gt; le due piattaforme sono abbastanza interscambibili. Inoltre, avere in più il mirino ottico &lt;em&gt;sempre attivo&lt;/em&gt; offre una visione più rilassante, disponibile anche a macchina spenta.&lt;/p&gt;

&lt;h2 id=&quot;inerzia&quot;&gt;Inerzia&lt;/h2&gt;
&lt;p&gt;Ci sono interi standard industriali che si basano sulla baionetta di certe reflex (pensiamo all’attrezzatura scientifica in montatura Nikon), oltre al workflow della quasi totalità dei professionisti sulla piazza.
Tonnellate di accessori, supporti, un intero ecosistema economico gravita attorno alla tecnologia delle reflex; come per certe tecnologie informatiche… avete presente il COBOL? Dagli anni ‘80 ad oggi l’avranno dato per morto una ventina di volte; fatevi un giro su LinkedIN e vedete quanto siano richiesti oggi i programmatori COBOL. Il legacy è una brutta bestia, ma è anche dove le aziende investono, è la base sulla quale costruiscono il loro business.&lt;/p&gt;

&lt;h2 id=&quot;alcune-noncuranze&quot;&gt;Alcune noncuranze&lt;/h2&gt;
&lt;p&gt;Non per problemi tecnologici o architetturali, ma ancora il segmento mirrorless presenta delle lacune eccellenti:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Niente corpi professionali al momento, e non sembrano in arrivo rapidamente. Ricordiamo che &lt;em&gt;no corpi pro&lt;/em&gt; &lt;strong&gt;=&amp;gt;&lt;/strong&gt; &lt;em&gt;no
ottiche pro&lt;/em&gt;. La rigidezza è tutto.&lt;/li&gt;
  &lt;li&gt;Nessun modello attuale ha un sistema di flash TTL maturo, o almeno usabile in contesti produttivi.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;User base&lt;/em&gt; piccola, e quindi nessun grosso investimento in massiccio in &lt;em&gt;R&amp;amp;D&lt;/em&gt;; il mercato langue, non ci sono grandi novità all’orizzonte. Paradossalmente, è molto più vivace il segmento dei dorsi digitali medio formato, che stanno finendo di soppiantare il 4x5.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quindi, tranquilli: &lt;strong&gt;DSLRs aren’t going anywhere&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/why_dslr_arent_going_anywhere/&quot;&gt;L&#39;insostenibile leggerezza dello specchio&lt;/a&gt; è stato originariamente pubblicato da Francesco Provino il &lt;a href=&quot;&quot;&gt;Francesco Provino&lt;/a&gt; su May 23, 2015.&lt;/p&gt;

  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[Sulla mistica dello storage enterprise]]></title>
  <link rel="alternate" type="text/html" href="/enterprise-storage/" />
  <id>/enterprise-storage</id>
  <updated>2015-05-21T00:00:00-00:00</updated>
  <published>2014-10-27T00:00:00+01:00</published>
  
  <author>
    <name>Francesco Provino</name>
    <uri></uri>
    
  </author>
  <content type="html">
    &lt;p&gt;Quello dello storage non-consumer è sicuramente uno dei settori dell’IT più floridi per quanto riguarda la nascita di miti e leggende: cosa favorita, oltre dal marketing dei big players, dall’oggettiva complessità di alcuni concetti in gioco e dalla diffusa ignoranza degli uomini-IT in merito.&lt;/p&gt;

&lt;p&gt;Vediamo di semplificare un po’, dando delle descrizioni “operative”.&lt;/p&gt;

&lt;h2 id=&quot;das&quot;&gt;DAS&lt;/h2&gt;
&lt;p&gt;Né più né meno dello storage interno del vostro server, ma ospitato in una enclosure esterna; da vedere come una “unità di espansione dischi” o “moltiplicatore di porte SAS esterno”. Generalmente il collegamento alle macchine avviene tramite cavi SAS (gli stessi che collegano i dischi locali), lo storage viene visto esattamente come uno o più dischi interni alla macchina. &lt;/p&gt;

&lt;p&gt;Come un qualsiasi controller SAS interno, sono muniti di funzionalità RAID e permettono di esporre partizioni, “array” dell’aggregato di dischi fisici, presentati alla macchina come normalissimi dispositivi a blocchi AKA dischi interni.&lt;/p&gt;

&lt;h2 id=&quot;san&quot;&gt;SAN&lt;/h2&gt;
&lt;p&gt;È qui che si concentrano la maggior parte degli equivoci, quindi diciamolo subito: la SAN non è altro che un DAS esposto ai servers tramite un protocollo di rete (iSCSI, FC, FCoE). Fine.
Più precisamente la Storage Area Network è un insieme di dispositivi, composta oltre dalla parte al quale viene generalmente attribuito il nome SAN, anche dagli switch e dagli HBA presenti sui servers; è giustappunto un &lt;strong&gt;network&lt;/strong&gt;, non un singolo dispositivo.&lt;/p&gt;

&lt;p&gt;È quindi possibile fare switching e routing del flusso di dati riguardanti lo storage, oltre a poter utilizzare il tutto in direct-attach similmente al DAS.
Cosa? Routing dello storage? Pazienza Iago, pazienza.&lt;/p&gt;

&lt;h2 id=&quot;nas&quot;&gt;NAS&lt;/h2&gt;
&lt;p&gt;Questo lo conosciamo bene tutti; un NAS è un fileserver che permette la condivisione dello storage a livello del filesystem, ovvero incorpora tutto lo stack necessario a presentare ai servers files e cartelle. Questo è l’unico dispositivo fra quelli presi in esame a permettere l’accesso allo storage a livello di files e non di blocchi; cioè, non è permesso accedere direttamente all’array di dischi fisici per partizionarlo, formattarlo ecc. Inoltre è l’unico, e sottolineo l’unico, ad incorporare la logica necessaria a gestire l’utilizzo in concorrenza di più macchine ad uno stesso pezzo di storage.&lt;/p&gt;

&lt;h2 id=&quot;e-allora&quot;&gt;E allora?&lt;/h2&gt;
&lt;p&gt;Come, la SAN non serviva per “condividere lo storage” fra più macchine? NO.
La SAN nasce principalmente per semplificare e rendere più efficiente la gestione dello spazio su disco di installazioni molto dense con parecchi servers, poiché è parecchio più semplice assegnare una LUN ad un server piuttosto versus spostare fisicamente (con ricostruzione array e quant’altro) dischi fra più macchine. In questo modo, è possibile assegnare dinamicamente “dischi” di dimensione variabile al server, senza interventi fisici e interruzioni dell’operatività: il punto che si possa fare su più macchine contemporaneamente, condividendo i dischi fisici, è la ragion
d’essere della SAN. &lt;/p&gt;

&lt;p&gt;In realtà, anche il DAS può fornire funzionalità di questo tipo se le macchine sono poche e abbastanza vicine allo storage, collegando direttamente i servers allo storage.
Nella caso della SAN, sia essa FC, FCoE o iSCSI, è addirittura possibile collegare lo storage e i servers a degli switch e persino a dei router in configurazioni simili a quelle di una tradizionale LAN, che permettono ad esempio di realizzare configurazioni che hanno particolari caratteristiche di resistenza ai guasti (utilizzando più SAN in replica, ad esempio).&lt;/p&gt;

&lt;p&gt;Andiamo oltre adesso; collegate due macchine fisiche alla stessa LUN di una SAN (con dei dati all’interno, magari): vi ritroverete con un filesystem irrimediabilmente corrotto dopo qualche secondo, e la totale distruzione dei dati sarebbe cosa inevitabile dopo pochi tentativi di scrittura.
Perché? Perché collegare una SAN a due macchine, è come collegare un ideale hard disk fisico con due cavi SAS a diversi computers: alla prima operazione contemporanea, vi ritrovate con un ammasso di bit insignificanti.
C’è un solo modo per gestire un hard disk condiviso fra due macchine: un filesystem distribuito, detto anche &lt;em&gt;clusterizzato&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;san--file-sharing&quot;&gt;SAN != File Sharing&lt;/h2&gt;
&lt;p&gt;L’errata considerazione della SAN come “storage di files condiviso” a mio parere nasce dalla grande facilità d’uso di VMFS di VMware, che permette l’uso “trasparente” della SAN, presentando gli array agli utenti proprio come farebbe un NAS, cioè come spazio formattato nel quale è possibile effettuare operazioni in concorrenza sui files. Ma attenzione: come nel caso del NAS, è il filesystem che si occupa di gestire la concorrenza, questo nulla ha a che vedere con le caratteristiche della SAN. Provate a configurare un filesystem clustered come GPFS o GFS, se volete capire profondamente come funzioni la cosa; è sempre bene sporcarsi un po’ le mani per arrivare ad una comprensione piena di certi meccanismi.&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;
&lt;p&gt;La tipologia di storage più performante in assoluto continua ad essere quello interno ai servers, ancor di più con il recente affermarsi di ssd PCI-E e memory-channel. Lo storage di rete, sia
esso SAN o NAS (e in una certa misura anche il DAS) è comunque limitato dall’overhead del protocollo di rete e dalla sua larghezza di banda.
L’ultima versione del FC quota 16Gbit/s, appena uscito e dai prezzi folli… Il PCI-E 3.0 16x fa circa 126Gbit/s, oggi, per slot, e sono già uscite le specifiche del 4.0 che avrà esattamente il doppio di banda; cambia poco negli ordini di grandezza se consideriamo iSCSI.
Il DAS ha generalmente poco overhead, scala in termini di multipli interi di porte SAS a 12Gbit/s.&lt;/p&gt;

&lt;h1 id=&quot;keep-it-simple-stupid&quot;&gt;Keep it simple, stupid!&lt;/h1&gt;
&lt;p&gt;Tutto questo può essere letto come un invito a semplificare il più possibile la topologia dello storage: si guadagna in prestazioni, si risparmia,  si ottiene un’affidabilità maggiore; la crescita di complessità può essere giustificata solamente quando non è assolutamente possibile soddisfare i requisiti progettuali senza aggiungere componenti o layer di astrazione.&lt;/p&gt;

&lt;p&gt;In generale, lo storage locale è sempre da preferire a tutte le altre alternative; la “catena cinematica” è la più corta, ciò porta a meno connettori/interfacce che possono guastarsi (o fare contatto intermittente, che è una delle cause più comuni del fail nei raid con parità), minore latenza e
prestazioni massime, oltre che semplicità di gestione.
La crescita di dimensioni dello storage può urtare i limiti fisici del singolo server, ed ecco che abbiamo bisogno di un DAS per la scalabilità.
Gli ambiti dove è opportuno utilizzare NAS e SAN enterprise dopo l’avvento dei meccanismi di replica software block-level e file-level, sono sempre più ristretti; in particolare, nel caso della SAN è necessario avere del personale iniziato ai misteri della condivisione block-level ed una
infrastruttura abbastanza ridondante, cosa che spesso si traduce in esborsi non indifferenti e difficilmente giustificabili nel mondo delle PMI.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/enterprise-storage/&quot;&gt;Sulla mistica dello storage enterprise&lt;/a&gt; è stato originariamente pubblicato da Francesco Provino il &lt;a href=&quot;&quot;&gt;Francesco Provino&lt;/a&gt; su October 27, 2014.&lt;/p&gt;

  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[Sopravvivere al velociraptor che cancella la tua tesi di laurea lanciando banane]]></title>
  <link rel="alternate" type="text/html" href="/git-faidate/" />
  <id>/git-faidate</id>
  <updated>2015-05-21T00:00:00-00:00</updated>
  <published>2014-09-15T00:00:00+02:00</published>
  
  <author>
    <name>Francesco Provino</name>
    <uri></uri>
    
  </author>
  <content type="html">
    &lt;p&gt;In questi giorni c’è stato tanto rumore mediatico riguardo alla violazione di account iCloud contenenti dati personali, e non sono mancate brecce in altri noti sistemi poco tempo addietro.&lt;/p&gt;

&lt;p&gt;I sistemi cloud proposti al mercato consumer per l’archiviazione dei dati da qualche altra parte hanno conosciuto una crescita incredibile negli ultimi anni, grazie e sopratutto al mercato mobile che ha posto l’accento sulla possibilità di guasti/furti del dispositivo: &lt;strong&gt;un cellulare è intrinsecamente più rubabile e danneggiabile di un PC desktop&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Mi sembra incredibile e sopratutto &lt;em&gt;inaccettabile&lt;/em&gt; che a 42 (!) anni dalla nascita di &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Source_Code_Control_System&quot;&gt;SCCS&lt;/a&gt;&lt;/strong&gt; si possano ancora perdere dei dati per l’ignoranza e/o l’incuria dell’operatore; ho visto parecchi miei conoscenti disperarsi di fronte a files corrotti, modifiche involontarie ma ormai salvate…&lt;/p&gt;

&lt;p&gt;Gli attuali sistemi di cloud storage come Dropbox, iCloud, Google drive ed altri (mi riferisco sempre a prodotti consumer) limitano molto la problematica, ma permangono delle criticità.&lt;/p&gt;

&lt;h4 id=&quot;privacy&quot;&gt;Privacy&lt;/h4&gt;
&lt;p&gt;Dove sono i miei dati? Chi ha i miei dati? Qualcuno fa analisi statistica/rivende metadati sui miei files? È possibile che io non possa più fisicamente accedere ai miei dati?&lt;/p&gt;

&lt;h4 id=&quot;limitazionicosti&quot;&gt;Limitazioni/Costi&lt;/h4&gt;
&lt;p&gt;Molti servizi offrono account gratuiti, ma in genere lo spazio disponibile è parecchio limitato… inoltre, vengono imposte delle limitazioni come il numero di repliche, la dimensione massima dei files, la tipologia di client (pensate ad iCloud!), l’accessibilità e la completa gestione gerarchica delle informazioni memorizzate. Esistono servizi enterprise-grade che superano buona parte di queste problematiche, ma i costi sono spesso proibitivi; Amazon S3 in questo è forse il miglior compromesso.&lt;/p&gt;

&lt;h4 id=&quot;condivisione&quot;&gt;Condivisione&lt;/h4&gt;
&lt;p&gt;La possibilità di far partecipare altri utenti al proprio repository di files è spesso parecchio limitata, a meno di non condividere direttamente l’account (ORRORE!). In generale, questi servizi si prestano poco a lavori in team perché non hanno modo di gestire modifiche concorrenti ad uno stesso file, spesso è necessario fare una copia locale delle informazioni interessate e poi processare nuovamente tutto a cose fatte… parecchio inefficiente! Si può fare di meglio.&lt;/p&gt;

&lt;h2 id=&quot;retrospettiva&quot;&gt;Retrospettiva&lt;/h2&gt;
&lt;p&gt;La mia risposta a questi requirements, viene dal passato: GIT, SSH, un po’ di shell aliasing. Strumenti affidabili, collaudati da generazioni di sviluppatori nel tempo, e sopratutto adatti ad un uso professionale… che oggi possiamo utilizzare anche per esigenze personali, dati i giganteschi passi avanti fatti da elaboratori alla portata di tutti. &lt;/p&gt;

&lt;p&gt;È molto significativo notare come si spaccino per &lt;em&gt;novità&lt;/em&gt; delle conquiste tecnologiche vecchiotte: il “cloud computing” nasce negli anni ‘60 con i mainframe IBM (avete presente &lt;em&gt;tn3270&lt;/em&gt; che accede ad ISPF? No?), i sistemi di controllo versione datano prima del 1975, telnet era disponibile già nel ‘68. 
Oggi è tutto parecchio più comodo, maturo e sicuro; il problema è semmai che l’allargamento della base di utenza anche ad analfabeti (non solo) informatici ha portato ad un deciso livellamento verso il basso delle interfacce utente, che richiedono sempre meno apprendistato e al contempo nascondono la grandissima parte delle tecnologie sottostanti alle finestre sbrilluccicose.&lt;/p&gt;

&lt;h2 id=&quot;requisiti&quot;&gt;Requisiti&lt;/h2&gt;
&lt;p&gt;Parlando di GIT, molti sviluppatori che mi leggeranno lo assoceranno al servizio GitHub; bene, quel che propongo io e di fare quello che fa GitHub lato server: &lt;strong&gt;diventare&lt;/strong&gt; GitHub, diventare il servizio, per avere pieno controllo sul posizionamento e la gestione dei nostri dati.&lt;/p&gt;

&lt;p&gt;Ecco la lista della spesa:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Due o più macchine con sistema POSIX o quasi-POSIX (Linux, UNIX, BSD, Mac OS X vanno benissimo); se siete dei temerari, anche Windows con CGYWIN. Nelle macchine dovranno essere installati ssh server e client, oltre ad ovviamente GIT ed una shell POSIX o similare a vostra scelta (io uso ZSH). &lt;/li&gt;
  &lt;li&gt;Una configurazione del network che vi permetta di raggiungere mutuamente le macchine su una porta a vostra scelta, anche attraverso NAT e reindirizzamenti vari va bene. Anzi, è consigliato: cambiate la porta di default per ssh. Fatelo. Punto. Riconfigurate le regole del firewall di conseguenza. &lt;/li&gt;
  &lt;li&gt;La capacità di non cominciare a scrivermi commenti stile “cosa è Linux?”, “non ho mai usato GIT, come si fa un commit? Cosa è un branch?”, “Ma io ho android”, “eh la peppa, io uso razzomissileOS e funziona tutto più meglio assai di quello che scrivi tu”: per informarvi su queste cose ci sono DOC e wiki ufficiali, io sto scrivendo di una metodologia per combinare insieme degli strumenti in un determinato scenario… per creare uno strumento nuovo.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Che lo spirito del RTFM vi accompagni sempre.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;uno-sguardo-dinsieme&quot;&gt;Uno sguardo d’insieme&lt;/h2&gt;
&lt;p&gt;Supposto quindi che sappiate usare GIT e siate anche dei sysadmin UNIX/Linux discretamente in allenamento, passiamo alla descrizione di alto livello di ciò che faremo. 
Presa una cartella contenente dei files nella nostra macchina, l’idea è che grazie a GIT ogni cambiamento del quale faremo un “commit” verrà registrato come “istantanea” di tutti i file presenti nella cartella (sto semplificando, possiamo aggiungere file che si trovano ovunque ovviamente): questa istantanea sarà anche corredata di un commento esplicativo dei cambiamenti effettuati, così da avere una storyline di tutto il nostro progetto.&lt;/p&gt;

&lt;p&gt;Inoltre, ed è questo il pezzo interessante, tutto questo repository contenente sia i file all’ultima versione sia tutte le versioni degli snapshots precedenti all’attuale sia tutti i commenti esplicativi alle varie revisioni, verrano replicati su &lt;em&gt;N&lt;/em&gt; macchine remote. Naturalmente, sarà anche possibile clonare tutto il repository da queste macchine per generare sia delle nuove cartelle di lavoro, sia dei nuovi repository master dai quali poter clonare tutto, ecc ecc. E questo, su qualsiasi dispositivo che abbia GIT ed accesso ad uno qualsiasi fra i servers. &lt;/p&gt;

&lt;p&gt;La connessione fra server e client, sulla quale opererà GIT, verrà incapsulata dentro il protocollo SSH utilizzato tramite scambio di chiavi asimmetrico di chiavi RSA (niente ID-password, grazie!). E tutta questa procedura verrà automatizzata, in modo da ridursi a un semplice comando, quantomeno per l’upload dei cambiamenti; leggi: “per pararsi il culo da perdite di dati”. 
Essendo il flusso di dati criptato tramite RSA, a meno di non fare delle fesserie nella config e di cambiare periodicamente le chiavi RSA (la crittografia asimmetrica è soggetta ad attacchi di tipo statistico, se le chiavi si usano a lungo), il sistema è utilizzabile anche da sistemi separati dalla WAN (su internet, ecco). Pensate al computer di casa e quello dell’ufficio, per esempio. O un altro pc da qualche altra parte del mondo, cambia nulla.&lt;/p&gt;

&lt;h2 id=&quot;dettagli-implementazione&quot;&gt;Dettagli implementazione&lt;/h2&gt;
&lt;p&gt;Passiamo alla realizzazione pratica: chiameremo &lt;strong&gt;A&lt;/strong&gt;-server la macchina server e &lt;strong&gt;B&lt;/strong&gt;-client la macchina client (indicherò con &lt;strong&gt;A&lt;/strong&gt;-server e &lt;strong&gt;B&lt;/strong&gt;-client anche gli IP/nomi_dns delle macchine): il server conterrà il repo sul quale pusheremo le modifiche, il nostro backup insomma, che potremmo anche clonare in altre macchine; il repository sul server sarà di tipo &lt;strong&gt;bare repo&lt;/strong&gt;, cioè conterrà i files codificati nei vari snapshots, ma nessuna cartella di lavoro per l’utente.&lt;/p&gt;

&lt;p&gt;Il client, oltre alla propria copia locale del repository, contenente tutto quanto è presente nel &lt;strong&gt;bare repo&lt;/strong&gt; (ma nella cartella locale nascosta .git), e ANCHE la cartella di lavoro (che tecnicamente è una copia dell’ultimo snapshot).
Usiamo repository &lt;strong&gt;bare&lt;/strong&gt; sul server per risparmiare spazio manca l’ulteriore clone dell’ultimo snapshot, detto “working tree”. &lt;/p&gt;

&lt;h4 id=&quot;warning&quot;&gt;Warning!&lt;/h4&gt;
&lt;p&gt;Questo non è un howto per utenti della prima ora, quindi molti passaggi che sono dipendenti dall’implementazione e del vostro sistema operativo verranno omessi: descrivo &lt;strong&gt;COSA&lt;/strong&gt; fare, ma non &lt;strong&gt;COME&lt;/strong&gt; fare; se avete letto una RFC nella vostra vita (o un libro di analisi matematica), non dovreste avere problemi.&lt;/p&gt;

&lt;h3 id=&quot;ssh-pairing&quot;&gt;SSH pairing&lt;/h3&gt;
&lt;p&gt;Per prima cosa, dobbiamo permettere alle due macchine di comunicare fra loro, naturalmente via ssh, senza dover inserire ogni volta username e password: a tale scopo, permetteremo il collegamento tramite pairing di chiavi RSA. Creiamo le chiavi sul client; accediamo ad essa e nel terminale digitiamo:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@B-client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;ssh-keygen&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;rsa&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;L’output confermerà la creazione. Creiamo quindi la cartella di destinazione sul server&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@B-client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;ssh&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@A-server&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.ssh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;e trasferiamo la chiave appena creata&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@B-client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.ssh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;id_rsa&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.pub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;ssh&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@A-server&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;cat &amp;gt;&amp;gt; .ssh/authorized_keys&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;assegnando i permessi corretti&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@B-client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;ssh&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@A-server&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;chmod 700 .ssh; chmod 640 .ssh/authorized_keys&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;verificate che sia possibile effettuare il login senza inserire credenzialia.
### Creazione dei repo
Creiamo quindi il repo in una cartella della macchina A-server; dopo esserci loggati in essa e aver creato la cartella /path/to/repo_server/, eseguiamo:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@A-server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--bare&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;repo_server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Questo sarà il nostro repository remoto. La configurazione sul server, ammesso di aver configurato correttamente ssh, firewall e il resto del networking, finisce qui… quindi, passiamo sul client! Creiamo il repository sul client, esattamente come fatto sul server:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@B-client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;repo_client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;e adesso, recidiamo il nodo gordiano: aggiungiamo l’origine remota al nostro repository. Ciò risponde alla domanda, “dove verrano mandati dati” da parte del 
client (che, ricordiamolo, è il sistema sul quale lavoriamo e del quale vogliamo avere un backup distribuito). Notare che nella riga sottostante sto usando una porta diversa dalla standard per ssh:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@B-client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;remote&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;A-server&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;ssh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;://&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@A-server&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;:60001&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;repo_server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Adesso proviamo a creare un file, fare un commit e poi l’output di&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@B-client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;A-server&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;dovrebbe confermare il funzionamento di quanto configurato, trasferendo gli elementi dal repo locale a quello remoto. Anche git status da ora in avanti terrà traccia dello status del repository remoto, segnalandovi quandi commit non avete ancora uploadato ecc. Una ulteriore conferma può essere data provando a clonare il repository remoto in locale:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;clone&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@A-server&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;:60001&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;repo_server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;automazione&quot;&gt;Automazione&lt;/h3&gt;
&lt;p&gt;Adesso che abbiamo un repository distribuito, possiamo aggiungere altri nodi-server o iniziare a cooperare con altri soggetti (anche non in LAN!) utilizzando il bare-repo come piattaforma per sviluppare qualsiasi progetto; ma sopratutto, possiamo rendere più ergonomico il funzionamento del sistema con dei piccoli aliasing (da mettere nel .bashrc, o ciò che usa la vostra shell in proposito) ad esempio possiamo syncare dei repo multipli remoti e/o locali, reindirizzando l’output dell’avvenuta (o meno) sincronizzazione ad un file di log:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;alias&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;syncall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;A-server&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.txt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;B-server&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.txt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;C-server&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.txt&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;un’altra cosa interessante, possono essere dei log arricchiti:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;alias&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;glog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;git log --stat --max-count=10&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;qualche-appunto-pratico-sulla-sicurezza&quot;&gt;Qualche appunto pratico sulla sicurezza&lt;/h2&gt;
&lt;p&gt;Cambiate SEMPRE la porta di default di ssh. SEMPRE. È il servizio più attaccato su sistemi UNIX-like. Anche se siete su CentOS e dovrete metter mano alle policy di SELINUX, fatelo. E mettete una porta alta, non standard. Non disattivate SELINUX o il firewall, per carità; sono cose che si configurano una tantum e poi funzionano sempre, mentre un’intrusione potrebbe rovinarvi, per sempre.&lt;/p&gt;

&lt;p&gt;Cambiate spesso le chiavi ssh se lavorate sulla rete internet. Ovviamente, non usate la stessa chiave per uploadare la nuova: fatevi un account a parte solo per queste operazioni, che usere solamente per cambio chiavi e compiti amministrativi: per i push in generale passa molta più roba, ed è attaccabile senza esagerate difficoltà se vi sniffano con una certa costanza. Magari un giorno scriverò anche di questo.&lt;/p&gt;

&lt;p&gt;Data la delicatezza dello scambio chiavi, sarebbe opportuno eseguire la prima sincronizzazione stando fisicamente collegati (o almeno in LAN) con il server, se il repo contiene dati sensibili.
Tenere tutto su ambienti virtualizzati con vm generalmente scollegate/spente che si attivano alla bisogna è sempre consigliabile.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/git-faidate/&quot;&gt;Sopravvivere al velociraptor che cancella la tua tesi di laurea lanciando banane&lt;/a&gt; è stato originariamente pubblicato da Francesco Provino il &lt;a href=&quot;&quot;&gt;Francesco Provino&lt;/a&gt; su September 15, 2014.&lt;/p&gt;

  </content>
</entry>

</feed>
